// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package bool

// ===========================================================================
// Beg of generation for interface{}

// Copyright 2018 Andreas Pannewitz. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

func boolInterface() { // to fool genny
}

// ===========================================================================

// interfaceIs represents a boolean predicate of interface{}
// implemented as a boolean function for anything of type interface.
type interfaceIs func(interface{}) bool

func isInterfaceTrue() interfaceIs  { return func(a interface{}) bool { return true } }
func isInterfaceFalse() interfaceIs { return func(a interface{}) bool { return false } }

// And evaluates to true, iff all predicates do so.
// Thus: And()() == true, as And() == isInterfaceTrue().
func (a interfaceIs) And(predicates ...func(interface{}) bool) interfaceIs {
	if a != nil {
		predicates = append([]func(interface{}) bool{a}, predicates...)
	}
	if len(predicates) < 1 {
		return isInterfaceTrue()
	}
	return func(a interface{}) bool {
		for _, predicate := range predicates {
			if !predicate(a) {
				return false
			}
		}
		return true
	}
}

// Or evaluates to true, iff at least one of the predicates does so.
// Thus: Or()() == false, as Or() == isInterfaceFalse().
func (a interfaceIs) Or(predicates ...func(interface{}) bool) interfaceIs {
	if a != nil {
		predicates = append([]func(interface{}) bool{a}, predicates...)
	}
	if len(predicates) < 1 {
		return isInterfaceFalse()
	}
	return func(a interface{}) bool {
		for _, predicate := range predicates {
			if predicate(a) {
				return true
			}
		}
		return false
	}
}

// Not evaluates to true, iff a evaluates to false or is nil.
// Thus: Not(nil)() == true, as Not(nil) == isInterfaceTrue().
func (a interfaceIs) Not() interfaceIs {
	if a == nil {
		return isInterfaceTrue()
	}
	return func(arg interface{}) bool {
		return !a(arg)
	}
}

// Is returns the predicate a unless it is nil
// in which case the isInterfaceFalse() predicate
// is returned which evaluates to false always.
func (a interfaceIs) Is() interfaceIs {
	if a == nil {
		return isInterfaceFalse()
	}
	return a
}

// Eval returns false if a is nil and returns
// the result of what a evaluates to
// for the given argument arg.
func (a interfaceIs) Eval(arg interface{}) bool {
	if a == nil {
		return false
	}
	return a(arg)
}

// End of generation for interface{}
// ===========================================================================

// ===========================================================================
// Beg of generation for Cardinality

// Copyright 2018 Andreas Pannewitz. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

func boolCardinality() { // to fool genny
}

// ===========================================================================

// CardinalityIs represents a boolean predicate of Cardinality
// implemented as a boolean function for anything of type Cardinality.
type CardinalityIs func(Cardinality) bool

func isCardinalityTrue() CardinalityIs  { return func(a Cardinality) bool { return true } }
func isCardinalityFalse() CardinalityIs { return func(a Cardinality) bool { return false } }

// And evaluates to true, iff all predicates do so.
// Thus: And()() == true, as And() == isCardinalityTrue().
func (a CardinalityIs) And(predicates ...func(Cardinality) bool) CardinalityIs {
	if a != nil {
		predicates = append([]func(Cardinality) bool{a}, predicates...)
	}
	if len(predicates) < 1 {
		return isCardinalityTrue()
	}
	return func(a Cardinality) bool {
		for _, predicate := range predicates {
			if !predicate(a) {
				return false
			}
		}
		return true
	}
}

// Or evaluates to true, iff at least one of the predicates does so.
// Thus: Or()() == false, as Or() == isCardinalityFalse().
func (a CardinalityIs) Or(predicates ...func(Cardinality) bool) CardinalityIs {
	if a != nil {
		predicates = append([]func(Cardinality) bool{a}, predicates...)
	}
	if len(predicates) < 1 {
		return isCardinalityFalse()
	}
	return func(a Cardinality) bool {
		for _, predicate := range predicates {
			if predicate(a) {
				return true
			}
		}
		return false
	}
}

// Not evaluates to true, iff a evaluates to false or is nil.
// Thus: Not(nil)() == true, as Not(nil) == isCardinalityTrue().
func (a CardinalityIs) Not() CardinalityIs {
	if a == nil {
		return isCardinalityTrue()
	}
	return func(arg Cardinality) bool {
		return !a(arg)
	}
}

// Is returns the predicate a unless it is nil
// in which case the isCardinalityFalse() predicate
// is returned which evaluates to false always.
func (a CardinalityIs) Is() CardinalityIs {
	if a == nil {
		return isCardinalityFalse()
	}
	return a
}

// Eval returns false if a is nil and returns
// the result of what a evaluates to
// for the given argument arg.
func (a CardinalityIs) Eval(arg Cardinality) bool {
	if a == nil {
		return false
	}
	return a(arg)
}

// End of generation for Cardinality
// ===========================================================================

// ===========================================================================
// Beg of generation for Index

// Copyright 2018 Andreas Pannewitz. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

func boolIndex() { // to fool genny
}

// ===========================================================================

// IndexIs represents a boolean predicate of Index
// implemented as a boolean function for anything of type Index.
type IndexIs func(Index) bool

func isIndexTrue() IndexIs  { return func(a Index) bool { return true } }
func isIndexFalse() IndexIs { return func(a Index) bool { return false } }

// And evaluates to true, iff all predicates do so.
// Thus: And()() == true, as And() == isIndexTrue().
func (a IndexIs) And(predicates ...func(Index) bool) IndexIs {
	if a != nil {
		predicates = append([]func(Index) bool{a}, predicates...)
	}
	if len(predicates) < 1 {
		return isIndexTrue()
	}
	return func(a Index) bool {
		for _, predicate := range predicates {
			if !predicate(a) {
				return false
			}
		}
		return true
	}
}

// Or evaluates to true, iff at least one of the predicates does so.
// Thus: Or()() == false, as Or() == isIndexFalse().
func (a IndexIs) Or(predicates ...func(Index) bool) IndexIs {
	if a != nil {
		predicates = append([]func(Index) bool{a}, predicates...)
	}
	if len(predicates) < 1 {
		return isIndexFalse()
	}
	return func(a Index) bool {
		for _, predicate := range predicates {
			if predicate(a) {
				return true
			}
		}
		return false
	}
}

// Not evaluates to true, iff a evaluates to false or is nil.
// Thus: Not(nil)() == true, as Not(nil) == isIndexTrue().
func (a IndexIs) Not() IndexIs {
	if a == nil {
		return isIndexTrue()
	}
	return func(arg Index) bool {
		return !a(arg)
	}
}

// Is returns the predicate a unless it is nil
// in which case the isIndexFalse() predicate
// is returned which evaluates to false always.
func (a IndexIs) Is() IndexIs {
	if a == nil {
		return isIndexFalse()
	}
	return a
}

// Eval returns false if a is nil and returns
// the result of what a evaluates to
// for the given argument arg.
func (a IndexIs) Eval(arg Index) bool {
	if a == nil {
		return false
	}
	return a(arg)
}

// End of generation for Index
// ===========================================================================

// ===========================================================================
// Beg of generation for ID

// Copyright 2018 Andreas Pannewitz. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

func boolID() { // to fool genny
}

// ===========================================================================

// IDIs represents a boolean predicate of ID
// implemented as a boolean function for anything of type ID.
type IDIs func(ID) bool

func isIDTrue() IDIs  { return func(a ID) bool { return true } }
func isIDFalse() IDIs { return func(a ID) bool { return false } }

// And evaluates to true, iff all predicates do so.
// Thus: And()() == true, as And() == isIDTrue().
func (a IDIs) And(predicates ...func(ID) bool) IDIs {
	if a != nil {
		predicates = append([]func(ID) bool{a}, predicates...)
	}
	if len(predicates) < 1 {
		return isIDTrue()
	}
	return func(a ID) bool {
		for _, predicate := range predicates {
			if !predicate(a) {
				return false
			}
		}
		return true
	}
}

// Or evaluates to true, iff at least one of the predicates does so.
// Thus: Or()() == false, as Or() == isIDFalse().
func (a IDIs) Or(predicates ...func(ID) bool) IDIs {
	if a != nil {
		predicates = append([]func(ID) bool{a}, predicates...)
	}
	if len(predicates) < 1 {
		return isIDFalse()
	}
	return func(a ID) bool {
		for _, predicate := range predicates {
			if predicate(a) {
				return true
			}
		}
		return false
	}
}

// Not evaluates to true, iff a evaluates to false or is nil.
// Thus: Not(nil)() == true, as Not(nil) == isIDTrue().
func (a IDIs) Not() IDIs {
	if a == nil {
		return isIDTrue()
	}
	return func(arg ID) bool {
		return !a(arg)
	}
}

// Is returns the predicate a unless it is nil
// in which case the isIDFalse() predicate
// is returned which evaluates to false always.
func (a IDIs) Is() IDIs {
	if a == nil {
		return isIDFalse()
	}
	return a
}

// Eval returns false if a is nil and returns
// the result of what a evaluates to
// for the given argument arg.
func (a IDIs) Eval(arg ID) bool {
	if a == nil {
		return false
	}
	return a(arg)
}

// End of generation for ID
// ===========================================================================

// ===========================================================================
// Beg of generation for Head

// Copyright 2018 Andreas Pannewitz. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

func boolHead() { // to fool genny
}

// ===========================================================================

// HeadIs represents a boolean predicate of Head
// implemented as a boolean function for anything of type Head.
type HeadIs func(Head) bool

func isHeadTrue() HeadIs  { return func(a Head) bool { return true } }
func isHeadFalse() HeadIs { return func(a Head) bool { return false } }

// And evaluates to true, iff all predicates do so.
// Thus: And()() == true, as And() == isHeadTrue().
func (a HeadIs) And(predicates ...func(Head) bool) HeadIs {
	if a != nil {
		predicates = append([]func(Head) bool{a}, predicates...)
	}
	if len(predicates) < 1 {
		return isHeadTrue()
	}
	return func(a Head) bool {
		for _, predicate := range predicates {
			if !predicate(a) {
				return false
			}
		}
		return true
	}
}

// Or evaluates to true, iff at least one of the predicates does so.
// Thus: Or()() == false, as Or() == isHeadFalse().
func (a HeadIs) Or(predicates ...func(Head) bool) HeadIs {
	if a != nil {
		predicates = append([]func(Head) bool{a}, predicates...)
	}
	if len(predicates) < 1 {
		return isHeadFalse()
	}
	return func(a Head) bool {
		for _, predicate := range predicates {
			if predicate(a) {
				return true
			}
		}
		return false
	}
}

// Not evaluates to true, iff a evaluates to false or is nil.
// Thus: Not(nil)() == true, as Not(nil) == isHeadTrue().
func (a HeadIs) Not() HeadIs {
	if a == nil {
		return isHeadTrue()
	}
	return func(arg Head) bool {
		return !a(arg)
	}
}

// Is returns the predicate a unless it is nil
// in which case the isHeadFalse() predicate
// is returned which evaluates to false always.
func (a HeadIs) Is() HeadIs {
	if a == nil {
		return isHeadFalse()
	}
	return a
}

// Eval returns false if a is nil and returns
// the result of what a evaluates to
// for the given argument arg.
func (a HeadIs) Eval(arg Head) bool {
	if a == nil {
		return false
	}
	return a(arg)
}

// End of generation for Head
// ===========================================================================

// ===========================================================================
// Beg of generation for Tail

// Copyright 2018 Andreas Pannewitz. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

func boolTail() { // to fool genny
}

// ===========================================================================

// TailIs represents a boolean predicate of Tail
// implemented as a boolean function for anything of type Tail.
type TailIs func(Tail) bool

func isTailTrue() TailIs  { return func(a Tail) bool { return true } }
func isTailFalse() TailIs { return func(a Tail) bool { return false } }

// And evaluates to true, iff all predicates do so.
// Thus: And()() == true, as And() == isTailTrue().
func (a TailIs) And(predicates ...func(Tail) bool) TailIs {
	if a != nil {
		predicates = append([]func(Tail) bool{a}, predicates...)
	}
	if len(predicates) < 1 {
		return isTailTrue()
	}
	return func(a Tail) bool {
		for _, predicate := range predicates {
			if !predicate(a) {
				return false
			}
		}
		return true
	}
}

// Or evaluates to true, iff at least one of the predicates does so.
// Thus: Or()() == false, as Or() == isTailFalse().
func (a TailIs) Or(predicates ...func(Tail) bool) TailIs {
	if a != nil {
		predicates = append([]func(Tail) bool{a}, predicates...)
	}
	if len(predicates) < 1 {
		return isTailFalse()
	}
	return func(a Tail) bool {
		for _, predicate := range predicates {
			if predicate(a) {
				return true
			}
		}
		return false
	}
}

// Not evaluates to true, iff a evaluates to false or is nil.
// Thus: Not(nil)() == true, as Not(nil) == isTailTrue().
func (a TailIs) Not() TailIs {
	if a == nil {
		return isTailTrue()
	}
	return func(arg Tail) bool {
		return !a(arg)
	}
}

// Is returns the predicate a unless it is nil
// in which case the isTailFalse() predicate
// is returned which evaluates to false always.
func (a TailIs) Is() TailIs {
	if a == nil {
		return isTailFalse()
	}
	return a
}

// Eval returns false if a is nil and returns
// the result of what a evaluates to
// for the given argument arg.
func (a TailIs) Eval(arg Tail) bool {
	if a == nil {
		return false
	}
	return a(arg)
}

// End of generation for Tail
// ===========================================================================

// ===========================================================================
// Beg of generation for Type

// Copyright 2018 Andreas Pannewitz. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

func boolType() { // to fool genny
}

// ===========================================================================

// TypeIs represents a boolean predicate of Type
// implemented as a boolean function for anything of type Type.
type TypeIs func(Type) bool

func isTypeTrue() TypeIs  { return func(a Type) bool { return true } }
func isTypeFalse() TypeIs { return func(a Type) bool { return false } }

// And evaluates to true, iff all predicates do so.
// Thus: And()() == true, as And() == isTypeTrue().
func (a TypeIs) And(predicates ...func(Type) bool) TypeIs {
	if a != nil {
		predicates = append([]func(Type) bool{a}, predicates...)
	}
	if len(predicates) < 1 {
		return isTypeTrue()
	}
	return func(a Type) bool {
		for _, predicate := range predicates {
			if !predicate(a) {
				return false
			}
		}
		return true
	}
}

// Or evaluates to true, iff at least one of the predicates does so.
// Thus: Or()() == false, as Or() == isTypeFalse().
func (a TypeIs) Or(predicates ...func(Type) bool) TypeIs {
	if a != nil {
		predicates = append([]func(Type) bool{a}, predicates...)
	}
	if len(predicates) < 1 {
		return isTypeFalse()
	}
	return func(a Type) bool {
		for _, predicate := range predicates {
			if predicate(a) {
				return true
			}
		}
		return false
	}
}

// Not evaluates to true, iff a evaluates to false or is nil.
// Thus: Not(nil)() == true, as Not(nil) == isTypeTrue().
func (a TypeIs) Not() TypeIs {
	if a == nil {
		return isTypeTrue()
	}
	return func(arg Type) bool {
		return !a(arg)
	}
}

// Is returns the predicate a unless it is nil
// in which case the isTypeFalse() predicate
// is returned which evaluates to false always.
func (a TypeIs) Is() TypeIs {
	if a == nil {
		return isTypeFalse()
	}
	return a
}

// Eval returns false if a is nil and returns
// the result of what a evaluates to
// for the given argument arg.
func (a TypeIs) Eval(arg Type) bool {
	if a == nil {
		return false
	}
	return a(arg)
}

// End of generation for Type
// ===========================================================================

// ===========================================================================
// Beg of generation for Container

// Copyright 2018 Andreas Pannewitz. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

func boolContainer() { // to fool genny
}

// ===========================================================================

// ContainerIs represents a boolean predicate of Container
// implemented as a boolean function for anything of type Container.
type ContainerIs func(Container) bool

func isContainerTrue() ContainerIs  { return func(a Container) bool { return true } }
func isContainerFalse() ContainerIs { return func(a Container) bool { return false } }

// And evaluates to true, iff all predicates do so.
// Thus: And()() == true, as And() == isContainerTrue().
func (a ContainerIs) And(predicates ...func(Container) bool) ContainerIs {
	if a != nil {
		predicates = append([]func(Container) bool{a}, predicates...)
	}
	if len(predicates) < 1 {
		return isContainerTrue()
	}
	return func(a Container) bool {
		for _, predicate := range predicates {
			if !predicate(a) {
				return false
			}
		}
		return true
	}
}

// Or evaluates to true, iff at least one of the predicates does so.
// Thus: Or()() == false, as Or() == isContainerFalse().
func (a ContainerIs) Or(predicates ...func(Container) bool) ContainerIs {
	if a != nil {
		predicates = append([]func(Container) bool{a}, predicates...)
	}
	if len(predicates) < 1 {
		return isContainerFalse()
	}
	return func(a Container) bool {
		for _, predicate := range predicates {
			if predicate(a) {
				return true
			}
		}
		return false
	}
}

// Not evaluates to true, iff a evaluates to false or is nil.
// Thus: Not(nil)() == true, as Not(nil) == isContainerTrue().
func (a ContainerIs) Not() ContainerIs {
	if a == nil {
		return isContainerTrue()
	}
	return func(arg Container) bool {
		return !a(arg)
	}
}

// Is returns the predicate a unless it is nil
// in which case the isContainerFalse() predicate
// is returned which evaluates to false always.
func (a ContainerIs) Is() ContainerIs {
	if a == nil {
		return isContainerFalse()
	}
	return a
}

// Eval returns false if a is nil and returns
// the result of what a evaluates to
// for the given argument arg.
func (a ContainerIs) Eval(arg Container) bool {
	if a == nil {
		return false
	}
	return a(arg)
}

// End of generation for Container
// ===========================================================================

// ===========================================================================
// Beg of generation for Indexed

// Copyright 2018 Andreas Pannewitz. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

func boolIndexed() { // to fool genny
}

// ===========================================================================

// IndexedIs represents a boolean predicate of Indexed
// implemented as a boolean function for anything of type Indexed.
type IndexedIs func(Indexed) bool

func isIndexedTrue() IndexedIs  { return func(a Indexed) bool { return true } }
func isIndexedFalse() IndexedIs { return func(a Indexed) bool { return false } }

// And evaluates to true, iff all predicates do so.
// Thus: And()() == true, as And() == isIndexedTrue().
func (a IndexedIs) And(predicates ...func(Indexed) bool) IndexedIs {
	if a != nil {
		predicates = append([]func(Indexed) bool{a}, predicates...)
	}
	if len(predicates) < 1 {
		return isIndexedTrue()
	}
	return func(a Indexed) bool {
		for _, predicate := range predicates {
			if !predicate(a) {
				return false
			}
		}
		return true
	}
}

// Or evaluates to true, iff at least one of the predicates does so.
// Thus: Or()() == false, as Or() == isIndexedFalse().
func (a IndexedIs) Or(predicates ...func(Indexed) bool) IndexedIs {
	if a != nil {
		predicates = append([]func(Indexed) bool{a}, predicates...)
	}
	if len(predicates) < 1 {
		return isIndexedFalse()
	}
	return func(a Indexed) bool {
		for _, predicate := range predicates {
			if predicate(a) {
				return true
			}
		}
		return false
	}
}

// Not evaluates to true, iff a evaluates to false or is nil.
// Thus: Not(nil)() == true, as Not(nil) == isIndexedTrue().
func (a IndexedIs) Not() IndexedIs {
	if a == nil {
		return isIndexedTrue()
	}
	return func(arg Indexed) bool {
		return !a(arg)
	}
}

// Is returns the predicate a unless it is nil
// in which case the isIndexedFalse() predicate
// is returned which evaluates to false always.
func (a IndexedIs) Is() IndexedIs {
	if a == nil {
		return isIndexedFalse()
	}
	return a
}

// Eval returns false if a is nil and returns
// the result of what a evaluates to
// for the given argument arg.
func (a IndexedIs) Eval(arg Indexed) bool {
	if a == nil {
		return false
	}
	return a(arg)
}

// End of generation for Indexed
// ===========================================================================

// ===========================================================================
// Beg of generation for Iterable

// Copyright 2018 Andreas Pannewitz. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

func boolIterable() { // to fool genny
}

// ===========================================================================

// IterableIs represents a boolean predicate of Iterable
// implemented as a boolean function for anything of type Iterable.
type IterableIs func(Iterable) bool

func isIterableTrue() IterableIs  { return func(a Iterable) bool { return true } }
func isIterableFalse() IterableIs { return func(a Iterable) bool { return false } }

// And evaluates to true, iff all predicates do so.
// Thus: And()() == true, as And() == isIterableTrue().
func (a IterableIs) And(predicates ...func(Iterable) bool) IterableIs {
	if a != nil {
		predicates = append([]func(Iterable) bool{a}, predicates...)
	}
	if len(predicates) < 1 {
		return isIterableTrue()
	}
	return func(a Iterable) bool {
		for _, predicate := range predicates {
			if !predicate(a) {
				return false
			}
		}
		return true
	}
}

// Or evaluates to true, iff at least one of the predicates does so.
// Thus: Or()() == false, as Or() == isIterableFalse().
func (a IterableIs) Or(predicates ...func(Iterable) bool) IterableIs {
	if a != nil {
		predicates = append([]func(Iterable) bool{a}, predicates...)
	}
	if len(predicates) < 1 {
		return isIterableFalse()
	}
	return func(a Iterable) bool {
		for _, predicate := range predicates {
			if predicate(a) {
				return true
			}
		}
		return false
	}
}

// Not evaluates to true, iff a evaluates to false or is nil.
// Thus: Not(nil)() == true, as Not(nil) == isIterableTrue().
func (a IterableIs) Not() IterableIs {
	if a == nil {
		return isIterableTrue()
	}
	return func(arg Iterable) bool {
		return !a(arg)
	}
}

// Is returns the predicate a unless it is nil
// in which case the isIterableFalse() predicate
// is returned which evaluates to false always.
func (a IterableIs) Is() IterableIs {
	if a == nil {
		return isIterableFalse()
	}
	return a
}

// Eval returns false if a is nil and returns
// the result of what a evaluates to
// for the given argument arg.
func (a IterableIs) Eval(arg Iterable) bool {
	if a == nil {
		return false
	}
	return a(arg)
}

// End of generation for Iterable
// ===========================================================================

// ===========================================================================
// Beg of generation for Named

// Copyright 2018 Andreas Pannewitz. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

func boolNamed() { // to fool genny
}

// ===========================================================================

// NamedIs represents a boolean predicate of Named
// implemented as a boolean function for anything of type Named.
type NamedIs func(Named) bool

func isNamedTrue() NamedIs  { return func(a Named) bool { return true } }
func isNamedFalse() NamedIs { return func(a Named) bool { return false } }

// And evaluates to true, iff all predicates do so.
// Thus: And()() == true, as And() == isNamedTrue().
func (a NamedIs) And(predicates ...func(Named) bool) NamedIs {
	if a != nil {
		predicates = append([]func(Named) bool{a}, predicates...)
	}
	if len(predicates) < 1 {
		return isNamedTrue()
	}
	return func(a Named) bool {
		for _, predicate := range predicates {
			if !predicate(a) {
				return false
			}
		}
		return true
	}
}

// Or evaluates to true, iff at least one of the predicates does so.
// Thus: Or()() == false, as Or() == isNamedFalse().
func (a NamedIs) Or(predicates ...func(Named) bool) NamedIs {
	if a != nil {
		predicates = append([]func(Named) bool{a}, predicates...)
	}
	if len(predicates) < 1 {
		return isNamedFalse()
	}
	return func(a Named) bool {
		for _, predicate := range predicates {
			if predicate(a) {
				return true
			}
		}
		return false
	}
}

// Not evaluates to true, iff a evaluates to false or is nil.
// Thus: Not(nil)() == true, as Not(nil) == isNamedTrue().
func (a NamedIs) Not() NamedIs {
	if a == nil {
		return isNamedTrue()
	}
	return func(arg Named) bool {
		return !a(arg)
	}
}

// Is returns the predicate a unless it is nil
// in which case the isNamedFalse() predicate
// is returned which evaluates to false always.
func (a NamedIs) Is() NamedIs {
	if a == nil {
		return isNamedFalse()
	}
	return a
}

// Eval returns false if a is nil and returns
// the result of what a evaluates to
// for the given argument arg.
func (a NamedIs) Eval(arg Named) bool {
	if a == nil {
		return false
	}
	return a(arg)
}

// End of generation for Named
// ===========================================================================

// ===========================================================================
// Beg of generation for Pair

// Copyright 2018 Andreas Pannewitz. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

func boolPair() { // to fool genny
}

// ===========================================================================

// PairIs represents a boolean predicate of Pair
// implemented as a boolean function for anything of type Pair.
type PairIs func(Pair) bool

func isPairTrue() PairIs  { return func(a Pair) bool { return true } }
func isPairFalse() PairIs { return func(a Pair) bool { return false } }

// And evaluates to true, iff all predicates do so.
// Thus: And()() == true, as And() == isPairTrue().
func (a PairIs) And(predicates ...func(Pair) bool) PairIs {
	if a != nil {
		predicates = append([]func(Pair) bool{a}, predicates...)
	}
	if len(predicates) < 1 {
		return isPairTrue()
	}
	return func(a Pair) bool {
		for _, predicate := range predicates {
			if !predicate(a) {
				return false
			}
		}
		return true
	}
}

// Or evaluates to true, iff at least one of the predicates does so.
// Thus: Or()() == false, as Or() == isPairFalse().
func (a PairIs) Or(predicates ...func(Pair) bool) PairIs {
	if a != nil {
		predicates = append([]func(Pair) bool{a}, predicates...)
	}
	if len(predicates) < 1 {
		return isPairFalse()
	}
	return func(a Pair) bool {
		for _, predicate := range predicates {
			if predicate(a) {
				return true
			}
		}
		return false
	}
}

// Not evaluates to true, iff a evaluates to false or is nil.
// Thus: Not(nil)() == true, as Not(nil) == isPairTrue().
func (a PairIs) Not() PairIs {
	if a == nil {
		return isPairTrue()
	}
	return func(arg Pair) bool {
		return !a(arg)
	}
}

// Is returns the predicate a unless it is nil
// in which case the isPairFalse() predicate
// is returned which evaluates to false always.
func (a PairIs) Is() PairIs {
	if a == nil {
		return isPairFalse()
	}
	return a
}

// Eval returns false if a is nil and returns
// the result of what a evaluates to
// for the given argument arg.
func (a PairIs) Eval(arg Pair) bool {
	if a == nil {
		return false
	}
	return a(arg)
}

// End of generation for Pair
// ===========================================================================

// ===========================================================================
// Beg of generation for Pile

// Copyright 2018 Andreas Pannewitz. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

func boolPile() { // to fool genny
}

// ===========================================================================

// PileIs represents a boolean predicate of Pile
// implemented as a boolean function for anything of type Pile.
type PileIs func(Pile) bool

func isPileTrue() PileIs  { return func(a Pile) bool { return true } }
func isPileFalse() PileIs { return func(a Pile) bool { return false } }

// And evaluates to true, iff all predicates do so.
// Thus: And()() == true, as And() == isPileTrue().
func (a PileIs) And(predicates ...func(Pile) bool) PileIs {
	if a != nil {
		predicates = append([]func(Pile) bool{a}, predicates...)
	}
	if len(predicates) < 1 {
		return isPileTrue()
	}
	return func(a Pile) bool {
		for _, predicate := range predicates {
			if !predicate(a) {
				return false
			}
		}
		return true
	}
}

// Or evaluates to true, iff at least one of the predicates does so.
// Thus: Or()() == false, as Or() == isPileFalse().
func (a PileIs) Or(predicates ...func(Pile) bool) PileIs {
	if a != nil {
		predicates = append([]func(Pile) bool{a}, predicates...)
	}
	if len(predicates) < 1 {
		return isPileFalse()
	}
	return func(a Pile) bool {
		for _, predicate := range predicates {
			if predicate(a) {
				return true
			}
		}
		return false
	}
}

// Not evaluates to true, iff a evaluates to false or is nil.
// Thus: Not(nil)() == true, as Not(nil) == isPileTrue().
func (a PileIs) Not() PileIs {
	if a == nil {
		return isPileTrue()
	}
	return func(arg Pile) bool {
		return !a(arg)
	}
}

// Is returns the predicate a unless it is nil
// in which case the isPileFalse() predicate
// is returned which evaluates to false always.
func (a PileIs) Is() PileIs {
	if a == nil {
		return isPileFalse()
	}
	return a
}

// Eval returns false if a is nil and returns
// the result of what a evaluates to
// for the given argument arg.
func (a PileIs) Eval(arg Pile) bool {
	if a == nil {
		return false
	}
	return a(arg)
}

// End of generation for Pile
// ===========================================================================
